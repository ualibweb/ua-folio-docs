# Backend Training â€“ OpenAPI

This section will focus on OpenAPI, the system used to define the APIs implemented and used by our
modules. OpenAPI is the current industry standard, and is very extensible; for the full
specification, please use [this link](https://spec.openapis.org/oas/latest.html).

> _Note: OpenAPI used to be called Swagger, before version 3. If you see Swagger mentioned in
> conversations/searches about OpenAPI, they are interchangeable and refer to the same thing._

At its core, OpenAPI is a simple way of declaring paths (e.g. `/hello`, `/entity/{id}`, etc.), their
methods (GET, POST, PUT, DELETE, etc), and the requests/responses applicable for each.

For example, let's look at part of the
["Swagger Petstore" API schema](https://github.com/swagger-api/swagger-petstore/blob/568715cb2f69a001808ea32a2489011214b51959/src/main/resources/openapi.yaml#L35-L65).
This declares an endpoint `POST /pet` to "Add a new pet to the store." Looking at the `requestBody`,
we see a JSON payload of a "Pet" is accepted; under responses we see successful operations will
return a Pet and 200 status code, while invalid inputs will return a 405. One of the most powerful
features of OpenAPI is the ability to reference other schemas, such as the Pet schema mentioned
earlier -- its
[implementation](https://github.com/swagger-api/swagger-petstore/blob/568715cb2f69a001808ea32a2489011214b51959/src/main/resources/openapi.yaml#L736-L776)
is a simple JSON schema. The API can be easily visualized in
[this documentation](https://petstore3.swagger.io/).

> Note: For an introduction to JSON schema, see
> [this article](https://json-schema.org/learn/getting-started-step-by-step.html). We typically
> write our schemas in YAML for readability, but everything else is the same.
>
> Also, although it is possible to combine all schemas and endpoints into one giant file, we prefer
> to split it across multiple files. The same `$ref` property can be used with filenames instead of
> local references. For an example of splitting up schemas and paths, see
> https://github.com/folio-org/mod-calendar/tree/d32a5431bc3a63a8f6c70e10aa1db557a8485147/src/main/resources/api.

This reusability makes it really easy to share data types and, as an added bonus, the components and
endpoints will automatically turned into Java code!

Now, for the actual coding portion of this lesson:

1. First, let's make a branch to keep these changes separate:

```sh
git checkout -b your-name-or-username-openapi
git push origin
```

1. Look in `target/generated-sources/openapi/src/main/java/org/folio/hello`. Here, you can see the
   code generated by OpenAPI.
   - The `api` folder contains the endpoint information -- don't worry about the specific code in
     here, only the method signatures are important.
   - We can see two real methods in here, buried under all the annotations:
     - `ResponseEntity<String> helloGet()`, which corresponds to our GET endpoint -- it takes no
       parameters and returns a String, and
     - `ResponseEntity<InlineResponse200> helloPost(Object body)`, our POST endpoint. The POST
       endpoint only defined that it took a body, but not what it would be, so the generic `Object`
       is used; similarly, the response object was given, but never named, so the creative name
       `InlineResponse200` was chosen.
   - In `model`, we can see the actual API components; in this case, only one exists: the POST
     response. Looking in this class, we see the `String greeting` and `Object data`, which
     corresponds exactly to the JSON schema we started with.
1. First, try extracting the POST response schema into a new file, ideally with a descriptive name.
   Run `mvn clean generate-sources` to clean out `/target` and regenerate the API code, then check
   and see how the generated code changed.
1. Next, try doing the same with the entire path description. Note, per the specification, the
   `paths:`
   [cannot directly use `$ref`](https://spec.openapis.org/oas/latest.html#patterned-fields), only
   the ["path items" can](https://spec.openapis.org/oas/latest.html#fixed-fields-6). For an example
   on how to do this, see
   [this API schema](https://github.com/folio-org/mod-calendar/blob/d32a5431bc3a63a8f6c70e10aa1db557a8485147/src/main/resources/api/calendar.yaml).
1. After doing the last few steps, be sure to run `mvn clean generate-sources` (to ensure no old
   code is still included) and re-run the application. Test that everything works before continuing.
1. Now, add OpenAPI specifications that can accomplish the following goals:

   - A GET endpoint `/sum` which takes two query parameters, `a` and `b`, and returns a JSON object
     `{"sum":#}` (where # is the integer sum of the two provided integers).
   - A POST endpoint `/sum` which takes a JSON request body:

     > ```json
     > {
     >   "inputs": [3, 4, -2, ...]
     > }
     > ```

     and returns the same kind of response as the GET request, for any number of input integers. If
     zero integers are provided, the sum should just be zero; do not worry about handling incorrect
     input.

1. At this point, create a commit, push it, and create a pull request from your openapi branch to
   your master branch. **Be sure you are creating a pull request against
   `ualibweb/folio-sample-modules` branch `your-name-master`, and not against anything in the
   folio-org repository.** Feel free to mark this as a draft while you're working through this
   document.
1. Now, try to implement these endpoints. An API class should have been generated separate from
   `HelloApi` that can then be implemented in a controller (use `HelloController` as an example).
1. Test that everything works in Insomnia
1. Once everything is to your satisfaction, commit and push your changes. Mark your pull request as
   ready for review (if applicable), and request someone review it.
1. While you're waiting on the review, move onto the next section:
   [02-unit-testing](02-unit-testing.md).
